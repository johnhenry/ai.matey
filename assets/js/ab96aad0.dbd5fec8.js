"use strict";(globalThis.webpackChunkai_matey_docs=globalThis.webpackChunkai_matey_docs||[]).push([[937],{1184:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var t=r(4041);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},8651:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"tutorials/beginner/multi-provider","title":"Tutorial 03: Multi-Provider Routing","description":"Learn how to use the Router to automatically distribute requests across multiple AI providers for load balancing, failover, and cost optimization.","source":"@site/docs/tutorials/beginner/03-multi-provider.md","sourceDirName":"tutorials/beginner","slug":"/tutorials/beginner/multi-provider","permalink":"/ai.matey/tutorials/beginner/multi-provider","draft":false,"unlisted":false,"editUrl":"https://github.com/johnhenry/ai.matey/tree/main/packages/ai.matey.docs/docs/tutorials/beginner/03-multi-provider.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docs","previous":{"title":"Tutorial 02: Using Middleware","permalink":"/ai.matey/tutorials/beginner/using-middleware"},"next":{"title":"Tutorial 04: Building a Chat API","permalink":"/ai.matey/tutorials/beginner/building-chat-api"}}');var a=r(1085),i=r(1184);const o={sidebar_position:3},s="Tutorial 03: Multi-Provider Routing",c={},l=[{value:"What You&#39;ll Build",id:"what-youll-build",level:2},{value:"Time Required",id:"time-required",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"What is a Router?",id:"what-is-a-router",level:2},{value:"Why Use a Router?",id:"why-use-a-router",level:3},{value:"Step 1: Install Packages",id:"step-1-install-packages",level:2},{value:"Step 2: Create a Basic Router",id:"step-2-create-a-basic-router",level:2},{value:"Routing Strategies",id:"routing-strategies",level:2},{value:"1. Round-Robin (Load Balancing)",id:"1-round-robin-load-balancing",level:3},{value:"2. Priority (Failover)",id:"2-priority-failover",level:3},{value:"3. Random",id:"3-random",level:3},{value:"4. Weighted",id:"4-weighted",level:3},{value:"5. Custom Strategy",id:"5-custom-strategy",level:3},{value:"Step 3: Automatic Failover",id:"step-3-automatic-failover",level:2},{value:"Step 4: Cost-Based Routing",id:"step-4-cost-based-routing",level:2},{value:"Step 5: Complexity-Based Routing",id:"step-5-complexity-based-routing",level:2},{value:"Middleware with Router",id:"middleware-with-router",level:2},{value:"Monitoring Router Health",id:"monitoring-router-health",level:2},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Environment-Based Routing",id:"environment-based-routing",level:3},{value:"Per-Request Provider Selection",id:"per-request-provider-selection",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"&quot;All backends failed&quot;",id:"all-backends-failed",level:3},{value:"&quot;Router not falling back&quot;",id:"router-not-falling-back",level:3},{value:"&quot;Routing is inconsistent&quot;",id:"routing-is-inconsistent",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Complete Example",id:"complete-example",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"tutorial-03-multi-provider-routing",children:"Tutorial 03: Multi-Provider Routing"})}),"\n",(0,a.jsx)(n.p,{children:"Learn how to use the Router to automatically distribute requests across multiple AI providers for load balancing, failover, and cost optimization."}),"\n",(0,a.jsx)(n.h2,{id:"what-youll-build",children:"What You'll Build"}),"\n",(0,a.jsx)(n.p,{children:"A Router that:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Load balances"})," across multiple providers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Automatically fails over"})," when a provider is down"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimizes costs"})," by routing to cheaper providers"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"time-required",children:"Time Required"}),"\n",(0,a.jsxs)(n.p,{children:["\u23f1\ufe0f ",(0,a.jsx)(n.strong,{children:"20 minutes"})]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Completed ",(0,a.jsx)(n.a,{href:"/tutorials/beginner/using-middleware",children:"Tutorial 02: Using Middleware"})]}),"\n",(0,a.jsxs)(n.li,{children:["At least ",(0,a.jsx)(n.strong,{children:"2 AI provider API keys"})," (e.g., OpenAI + Anthropic)"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"what-is-a-router",children:"What is a Router?"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.strong,{children:"Router"})," is like a Bridge, but it can work with ",(0,a.jsx)(n.strong,{children:"multiple backend providers"})," simultaneously. It decides which provider to use for each request based on a ",(0,a.jsx)(n.strong,{children:"routing strategy"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Your Request\n     \u2193\n   Router\n  /  |  \\\n /   |   \\\nBackend Backend Backend\n  1      2      3\nOpenAI Anthropic Groq\n"})}),"\n",(0,a.jsx)(n.h3,{id:"why-use-a-router",children:"Why Use a Router?"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Load Balancing"}),": Distribute load evenly across providers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"High Availability"}),": Auto-failover if a provider fails"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cost Optimization"}),": Route to cheaper providers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance"}),": Use fastest provider for each request"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Testing"}),": A/B test different providers"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"step-1-install-packages",children:"Step 1: Install Packages"}),"\n",(0,a.jsxs)(n.p,{children:["You already have ",(0,a.jsx)(n.code,{children:"ai.matey.core"}),", now install more backend adapters:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"npm install ai.matey.backend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-2-create-a-basic-router",children:"Step 2: Create a Basic Router"}),"\n",(0,a.jsx)(n.p,{children:"Create a Router with multiple backends:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { Router } from 'ai.matey.core';\nimport { OpenAIFrontendAdapter } from 'ai.matey.frontend/openai';\nimport { AnthropicBackendAdapter } from 'ai.matey.backend/anthropic';\nimport { OpenAIBackendAdapter } from 'ai.matey.backend/openai';\n\nconst router = new Router(\n  new OpenAIFrontendAdapter(),\n  {\n    backends: [\n      new AnthropicBackendAdapter({\n        apiKey: process.env.ANTHROPIC_API_KEY\n      }),\n      new OpenAIBackendAdapter({\n        apiKey: process.env.OPENAI_API_KEY\n      })\n    ],\n    strategy: 'round-robin' // Alternate between providers\n  }\n);\n\n// First request \u2192 Anthropic\nconst response1 = await router.chat({\n  model: 'gpt-4',\n  messages: [{ role: 'user', content: 'Hello' }]\n});\n\n// Second request \u2192 OpenAI\nconst response2 = await router.chat({\n  model: 'gpt-4',\n  messages: [{ role: 'user', content: 'Hi' }]\n});\n\n// Third request \u2192 Anthropic (cycles back)\nconst response3 = await router.chat({\n  model: 'gpt-4',\n  messages: [{ role: 'user', content: 'Hey' }]\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"routing-strategies",children:"Routing Strategies"}),"\n",(0,a.jsx)(n.h3,{id:"1-round-robin-load-balancing",children:"1. Round-Robin (Load Balancing)"}),"\n",(0,a.jsx)(n.p,{children:"Distributes requests evenly:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [backend1, backend2, backend3],\n  strategy: 'round-robin'\n});\n\n// Request 1 \u2192 Backend 1\n// Request 2 \u2192 Backend 2\n// Request 3 \u2192 Backend 3\n// Request 4 \u2192 Backend 1 (cycles)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use case"}),": Even load distribution, all providers have similar pricing/performance."]}),"\n",(0,a.jsx)(n.h3,{id:"2-priority-failover",children:"2. Priority (Failover)"}),"\n",(0,a.jsx)(n.p,{children:"Uses providers in order, falls back if one fails:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [\n    primaryBackend,   // Try this first\n    secondaryBackend, // Fallback if primary fails\n    tertiaryBackend   // Last resort\n  ],\n  strategy: 'priority',\n  fallbackOnError: true\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use case"}),": High availability, redundancy, disaster recovery."]}),"\n",(0,a.jsx)(n.h3,{id:"3-random",children:"3. Random"}),"\n",(0,a.jsx)(n.p,{children:"Selects a random backend for each request:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [backend1, backend2, backend3],\n  strategy: 'random'\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use case"}),": Simple distribution, testing."]}),"\n",(0,a.jsx)(n.h3,{id:"4-weighted",children:"4. Weighted"}),"\n",(0,a.jsx)(n.p,{children:"Some providers get more traffic:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [\n    { backend: backend1, weight: 70 }, // 70% of traffic\n    { backend: backend2, weight: 20 }, // 20% of traffic\n    { backend: backend3, weight: 10 }  // 10% of traffic\n  ],\n  strategy: 'weighted'\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use case"}),": A/B testing, gradual provider migration, canary deployments."]}),"\n",(0,a.jsx)(n.h3,{id:"5-custom-strategy",children:"5. Custom Strategy"}),"\n",(0,a.jsx)(n.p,{children:"Write your own routing logic:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [cheapBackend, fastBackend, powerfulBackend],\n  strategy: 'custom',\n  customStrategy: (request) => {\n    // Route based on your logic\n    const isComplex = request.messages.length > 10;\n    const needsSpeed = request.max_tokens < 100;\n\n    if (needsSpeed) return 1;      // Fast backend\n    if (isComplex) return 2;       // Powerful backend\n    return 0;                      // Cheap backend\n  }\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use case"}),": Cost optimization, complexity-based routing, performance tuning."]}),"\n",(0,a.jsx)(n.h2,{id:"step-3-automatic-failover",children:"Step 3: Automatic Failover"}),"\n",(0,a.jsx)(n.p,{children:"Handle provider failures gracefully:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { Router } from 'ai.matey.core';\nimport { OpenAIFrontendAdapter } from 'ai.matey.frontend/openai';\nimport { AnthropicBackendAdapter } from 'ai.matey.backend/anthropic';\nimport { OpenAIBackendAdapter } from 'ai.matey.backend/openai';\nimport { GroqBackendAdapter } from 'ai.matey.backend/groq';\n\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [\n    new AnthropicBackendAdapter({ apiKey: process.env.ANTHROPIC_API_KEY }),\n    new OpenAIBackendAdapter({ apiKey: process.env.OPENAI_API_KEY }),\n    new GroqBackendAdapter({ apiKey: process.env.GROQ_API_KEY })\n  ],\n  strategy: 'priority',\n  fallbackOnError: true,\n  healthCheck: {\n    enabled: true,\n    interval: 60000, // Check every minute\n    timeout: 5000\n  }\n});\n\n// Listen for failover events\nrouter.on('backend:failed', ({ backend, error }) => {\n  console.log(`\u274c ${backend} failed: ${error.message}`);\n});\n\nrouter.on('backend:switch', ({ from, to }) => {\n  console.log(`\ud83d\udd04 Switched from ${from} to ${to}`);\n});\n\n// If Anthropic is down, automatically uses OpenAI\nconst response = await router.chat({\n  model: 'gpt-4',\n  messages: [{ role: 'user', content: 'Hello' }]\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Console output (if Anthropic is down):"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"\u274c anthropic failed: Connection timeout\n\ud83d\udd04 Switched from anthropic to openai\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-4-cost-based-routing",children:"Step 4: Cost-Based Routing"}),"\n",(0,a.jsx)(n.p,{children:"Route to the cheapest provider that meets quality requirements:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Provider pricing (per 1K tokens)\nconst PRICING = {\n  groq: 0.00027,\n  deepseek: 0.0002,\n  anthropic: 0.0008,\n  openai: 0.0015\n};\n\nfunction selectCheapestProvider(request, backends) {\n  // Estimate tokens\n  const estimatedTokens = Math.ceil(\n    (JSON.stringify(request.messages).length + 200) / 4\n  );\n\n  // Find cheapest\n  let cheapestIndex = 0;\n  let lowestCost = Infinity;\n\n  backends.forEach((backend, index) => {\n    const cost = PRICING[backend.name] * estimatedTokens / 1000;\n    if (cost < lowestCost) {\n      lowestCost = cost;\n      cheapestIndex = index;\n    }\n  });\n\n  return cheapestIndex;\n}\n\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [\n    new GroqBackendAdapter({ apiKey: process.env.GROQ_API_KEY }),\n    new DeepSeekBackendAdapter({ apiKey: process.env.DEEPSEEK_API_KEY }),\n    new AnthropicBackendAdapter({ apiKey: process.env.ANTHROPIC_API_KEY }),\n    new OpenAIBackendAdapter({ apiKey: process.env.OPENAI_API_KEY })\n  ],\n  strategy: 'custom',\n  customStrategy: selectCheapestProvider\n});\n\n// Always routes to cheapest provider\nconst response = await router.chat({\n  model: 'gpt-4',\n  messages: [{ role: 'user', content: 'Short query' }]\n});\n// \u2192 Uses Groq or DeepSeek (cheapest)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-5-complexity-based-routing",children:"Step 5: Complexity-Based Routing"}),"\n",(0,a.jsx)(n.p,{children:"Route simple queries to cheap models, complex ones to powerful models:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function analyzeComplexity(request) {\n  const lastMessage = request.messages[request.messages.length - 1];\n  const content = lastMessage.content.toString();\n\n  let score = 0;\n\n  // Length factor\n  const wordCount = content.split(/\\s+/).length;\n  score += Math.min(wordCount / 2, 30);\n\n  // Complexity keywords\n  const complexKeywords = ['analyze', 'explain', 'compare', 'evaluate', 'why'];\n  if (complexKeywords.some(kw => content.toLowerCase().includes(kw))) {\n    score += 20;\n  }\n\n  // Math or code\n  if (/\\d+\\s*[+\\-*/]\\s*\\d+/.test(content)) score += 15;\n  if (/```/.test(content)) score += 15;\n\n  return Math.min(score, 100);\n}\n\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [\n    new GroqBackendAdapter({ apiKey: process.env.GROQ_API_KEY }),        // Fast, cheap\n    new DeepSeekBackendAdapter({ apiKey: process.env.DEEPSEEK_API_KEY }), // Cost-effective\n    new OpenAIBackendAdapter({ apiKey: process.env.OPENAI_API_KEY }),    // Powerful\n    new AnthropicBackendAdapter({ apiKey: process.env.ANTHROPIC_API_KEY }) // Most capable\n  ],\n  strategy: 'custom',\n  customStrategy: (request) => {\n    const complexity = analyzeComplexity(request);\n\n    if (complexity < 25) return 0; // Groq: Simple queries\n    if (complexity < 50) return 1; // DeepSeek: Moderate\n    if (complexity < 80) return 2; // OpenAI: Complex\n    return 3; // Anthropic: Very complex\n  }\n});\n\n// Simple query \u2192 Groq\nawait router.chat({\n  model: 'gpt-4',\n  messages: [{ role: 'user', content: 'What is 2+2?' }]\n});\n\n// Complex query \u2192 Anthropic\nawait router.chat({\n  model: 'gpt-4',\n  messages: [{\n    role: 'user',\n    content: 'Analyze the philosophical implications of AI consciousness and compare different theories'\n  }]\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"middleware-with-router",children:"Middleware with Router"}),"\n",(0,a.jsx)(n.p,{children:"You can add middleware to Routers just like Bridges:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { createLoggingMiddleware } from 'ai.matey.middleware';\n\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [backend1, backend2],\n  strategy: 'round-robin'\n});\n\nrouter.use(createLoggingMiddleware({ level: 'info' }));\nrouter.use(createRetryMiddleware({ maxAttempts: 3 }));\nrouter.use(createCachingMiddleware({ ttl: 3600 }));\n"})}),"\n",(0,a.jsx)(n.h2,{id:"monitoring-router-health",children:"Monitoring Router Health"}),"\n",(0,a.jsx)(n.p,{children:"Track which backends are healthy:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"router.on('backend:health', ({ backend, healthy }) => {\n  console.log(`${backend}: ${healthy ? '\u2705 Healthy' : '\u274c Unhealthy'}`);\n});\n\n// Get current health status\nconst health = await router.getBackendHealth();\nconsole.log(health);\n/*\n{\n  anthropic: { healthy: true, latency: 1200, errorRate: 0 },\n  openai: { healthy: true, latency: 1500, errorRate: 0.02 },\n  groq: { healthy: false, latency: 5000, errorRate: 0.5 }\n}\n*/\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"environment-based-routing",children:"Environment-Based Routing"}),"\n",(0,a.jsx)(n.p,{children:"Use different providers for dev/staging/prod:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const backends =\n  process.env.NODE_ENV === 'production'\n    ? [\n        new AnthropicBackendAdapter({ apiKey: process.env.ANTHROPIC_API_KEY }),\n        new OpenAIBackendAdapter({ apiKey: process.env.OPENAI_API_KEY })\n      ]\n    : [\n        new OllamaBackendAdapter({ baseURL: 'http://localhost:11434' })\n      ];\n\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends,\n  strategy: 'priority',\n  fallbackOnError: true\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"per-request-provider-selection",children:"Per-Request Provider Selection"}),"\n",(0,a.jsx)(n.p,{children:"Override routing for specific requests:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Use default routing\nconst response1 = await router.chat({\n  model: 'gpt-4',\n  messages: [{ role: 'user', content: 'Hello' }]\n});\n\n// Force specific backend\nconst response2 = await router.chat({\n  model: 'gpt-4',\n  messages: [{ role: 'user', content: 'Hello' }],\n  backend: 'anthropic' // Force Anthropic\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(n.h3,{id:"all-backends-failed",children:'"All backends failed"'}),"\n",(0,a.jsx)(n.p,{children:"Make sure at least one backend has a valid API key:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good - at least one working backend\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [\n    new OpenAIBackendAdapter({ apiKey: validKey }),\n    new AnthropicBackendAdapter({ apiKey: invalidKey }) // This can fail\n  ],\n  fallbackOnError: true\n});\n\n// \u274c Bad - all backends will fail\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [\n    new OpenAIBackendAdapter({ apiKey: null }),\n    new AnthropicBackendAdapter({ apiKey: null })\n  ]\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"router-not-falling-back",children:'"Router not falling back"'}),"\n",(0,a.jsxs)(n.p,{children:["Enable ",(0,a.jsx)(n.code,{children:"fallbackOnError"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [backend1, backend2],\n  strategy: 'priority',\n  fallbackOnError: true // Don't forget this!\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"routing-is-inconsistent",children:'"Routing is inconsistent"'}),"\n",(0,a.jsx)(n.p,{children:"For round-robin, make sure you're reusing the same Router instance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Correct - reuse instance\nconst router = new Router(...);\nawait router.chat(...); // Backend 1\nawait router.chat(...); // Backend 2\nawait router.chat(...); // Backend 3\n\n// \u274c Wrong - creates new router each time\nasync function chat() {\n  const router = new Router(...); // Fresh state!\n  return await router.chat(...);\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(n.p,{children:"Excellent! You now know how to use multi-provider routing."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Continue learning:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/tutorials/beginner/building-chat-api",children:"Tutorial 04: Building a Chat API"})," - Create an HTTP server"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/johnhenry/ai.matey/tree/main/packages/ai.matey.docs/examples/04-routing",children:"Routing Examples"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/patterns",children:"Integration Patterns"})," - Production-ready patterns"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// multi-provider-router.js\nimport 'dotenv/config';\nimport { Router } from 'ai.matey.core';\nimport { OpenAIFrontendAdapter } from 'ai.matey.frontend/openai';\nimport { AnthropicBackendAdapter } from 'ai.matey.backend/anthropic';\nimport { OpenAIBackendAdapter } from 'ai.matey.backend/openai';\nimport { GroqBackendAdapter } from 'ai.matey.backend/groq';\nimport { createLoggingMiddleware } from 'ai.matey.middleware';\n\n// Create router with multiple backends\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [\n    new AnthropicBackendAdapter({\n      apiKey: process.env.ANTHROPIC_API_KEY\n    }),\n    new OpenAIBackendAdapter({\n      apiKey: process.env.OPENAI_API_KEY\n    }),\n    new GroqBackendAdapter({\n      apiKey: process.env.GROQ_API_KEY\n    })\n  ],\n  strategy: 'priority',\n  fallbackOnError: true,\n  healthCheck: {\n    enabled: true,\n    interval: 60000\n  }\n});\n\n// Add logging\nrouter.use(createLoggingMiddleware({ level: 'info' }));\n\n// Event handlers\nrouter.on('backend:failed', ({ backend, error }) => {\n  console.error(`\u274c ${backend} failed: ${error.message}`);\n});\n\nrouter.on('backend:switch', ({ from, to }) => {\n  console.log(`\ud83d\udd04 Switched from ${from} to ${to}`);\n});\n\n// Use it\nasync function chat(message) {\n  const response = await router.chat({\n    model: 'gpt-4',\n    messages: [{ role: 'user', content: message }]\n  });\n  return response.choices[0].message.content;\n}\n\n// Test\nconsole.log(await chat('What is ai.matey?'));\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Ready to build an API?"})," Continue to ",(0,a.jsx)(n.a,{href:"/tutorials/beginner/building-chat-api",children:"Tutorial 04: Building a Chat API"})]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);