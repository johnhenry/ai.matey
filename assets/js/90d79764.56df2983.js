"use strict";(globalThis.webpackChunkai_matey_docs=globalThis.webpackChunkai_matey_docs||[]).push([[7961],{1184:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var t=i(4041);const r={},s=t.createContext(r);function l(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(s.Provider,{value:n},e.children)}},5478:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"patterns/index","title":"Integration Patterns","description":"Production-validated integration patterns for ai.matey, discovered and tested through comprehensive integration testing.","source":"@site/docs/patterns/index.md","sourceDirName":"patterns","slug":"/patterns/","permalink":"/ai.matey/patterns/","draft":false,"unlisted":false,"editUrl":"https://github.com/johnhenry/ai.matey/tree/main/packages/ai.matey.docs/docs/patterns/index.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docs","previous":{"title":"Testing","permalink":"/ai.matey/guides/testing/"},"next":{"title":"API Reference","permalink":"/ai.matey/api/"}}');var r=i(1085),s=i(1184);const l={sidebar_position:1},o="Integration Patterns",a={},d=[{value:"Overview",id:"overview",level:2},{value:"Complexity-Based Routing",id:"complexity-based-routing",level:2},{value:"Problem",id:"problem",level:3},{value:"Solution",id:"solution",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Results",id:"results",level:3},{value:"When to Use",id:"when-to-use",level:3},{value:"Parallel Provider Aggregation",id:"parallel-provider-aggregation",level:2},{value:"Problem",id:"problem-1",level:3},{value:"Solution",id:"solution-1",level:3},{value:"Implementation",id:"implementation-1",level:3},{value:"Results",id:"results-1",level:3},{value:"When to Use",id:"when-to-use-1",level:3},{value:"Automatic Failover",id:"automatic-failover",level:2},{value:"Problem",id:"problem-2",level:3},{value:"Solution",id:"solution-2",level:3},{value:"Implementation",id:"implementation-2",level:3},{value:"Results",id:"results-2",level:3},{value:"When to Use",id:"when-to-use-2",level:3},{value:"Cost-Optimized Selection",id:"cost-optimized-selection",level:2},{value:"Problem",id:"problem-3",level:3},{value:"Solution",id:"solution-3",level:3},{value:"Implementation",id:"implementation-3",level:3},{value:"Results",id:"results-3",level:3},{value:"When to Use",id:"when-to-use-3",level:3},{value:"WebSocket Real-Time Streaming",id:"websocket-real-time-streaming",level:2},{value:"Problem",id:"problem-4",level:3},{value:"Solution",id:"solution-4",level:3},{value:"Implementation",id:"implementation-4",level:3},{value:"Results",id:"results-4",level:3},{value:"When to Use",id:"when-to-use-4",level:3},{value:"Batch Processing with Rate Limiting",id:"batch-processing-with-rate-limiting",level:2},{value:"Problem",id:"problem-5",level:3},{value:"Solution",id:"solution-5",level:3},{value:"Implementation",id:"implementation-5",level:3},{value:"Results",id:"results-5",level:3},{value:"When to Use",id:"when-to-use-5",level:3},{value:"Advanced Middleware Composition",id:"advanced-middleware-composition",level:2},{value:"Implementation",id:"implementation-6",level:3},{value:"When to Use",id:"when-to-use-6",level:3},{value:"Continuous Health Monitoring",id:"continuous-health-monitoring",level:2},{value:"Implementation",id:"implementation-7",level:3},{value:"When to Use",id:"when-to-use-7",level:3},{value:"See Also",id:"see-also",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"integration-patterns",children:"Integration Patterns"})}),"\n",(0,r.jsx)(n.p,{children:"Production-validated integration patterns for ai.matey, discovered and tested through comprehensive integration testing."}),"\n",(0,r.jsx)(n.admonition,{title:"Validation",type:"info",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": 8 advanced test applications (50+ scenarios)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test Results"}),": 100% pass rate across all patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Status"}),": Production-ready"]}),"\n"]})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"These patterns emerged from real-world testing scenarios and represent battle-tested approaches to common challenges:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Pattern"}),(0,r.jsx)(n.th,{children:"Use Case"}),(0,r.jsx)(n.th,{children:"Complexity"}),(0,r.jsx)(n.th,{children:"Status"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"#complexity-based-routing",children:"Complexity-Based Routing"})}),(0,r.jsx)(n.td,{children:"Cost/quality optimization"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"\u2705 Production-ready"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"#parallel-provider-aggregation",children:"Parallel Provider Aggregation"})}),(0,r.jsx)(n.td,{children:"A/B testing, redundancy"}),(0,r.jsx)(n.td,{children:"Advanced"}),(0,r.jsx)(n.td,{children:"\u2705 Production-ready"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"#automatic-failover",children:"Automatic Failover"})}),(0,r.jsx)(n.td,{children:"Resilience"}),(0,r.jsx)(n.td,{children:"Advanced"}),(0,r.jsx)(n.td,{children:"\u2705 Production-ready"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"#cost-optimized-selection",children:"Cost-Optimized Selection"})}),(0,r.jsx)(n.td,{children:"Cost reduction"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"\u2705 Production-ready"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"#websocket-real-time-streaming",children:"WebSocket Real-Time Streaming"})}),(0,r.jsx)(n.td,{children:"Real-time chat"}),(0,r.jsx)(n.td,{children:"Advanced"}),(0,r.jsx)(n.td,{children:"\u2705 Production-ready"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"#batch-processing-with-rate-limiting",children:"Batch Processing"})}),(0,r.jsx)(n.td,{children:"High throughput"}),(0,r.jsx)(n.td,{children:"Advanced"}),(0,r.jsx)(n.td,{children:"\u2705 Production-ready"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"#advanced-middleware-composition",children:"Middleware Composition"})}),(0,r.jsx)(n.td,{children:"Request pipeline"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"\u2705 Production-ready"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"#continuous-health-monitoring",children:"Health Monitoring"})}),(0,r.jsx)(n.td,{children:"Observability"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"\u2705 Production-ready"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"complexity-based-routing",children:"Complexity-Based Routing"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Route queries to appropriate providers based on complexity to optimize cost and quality."]}),"\n",(0,r.jsx)(n.h3,{id:"problem",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"Different queries require different model capabilities. Routing all queries to the most powerful (and expensive) model wastes money. Routing to cheaper models sacrifices quality on complex tasks."}),"\n",(0,r.jsx)(n.h3,{id:"solution",children:"Solution"}),"\n",(0,r.jsx)(n.p,{children:"Analyze query complexity and route to appropriate providers based on a complexity score."}),"\n",(0,r.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Router } from 'ai.matey.core';\n\n// Complexity analyzer\nfunction analyzeComplexity(query: string): number {\n  let score = 0;\n\n  // Word count (longer = more complex)\n  const wordCount = query.split(/\\s+/).length;\n  score += Math.min(wordCount / 2, 30);\n\n  // Keywords indicating complexity\n  const complexKeywords = ['analyze', 'explain', 'compare', 'evaluate'];\n  if (complexKeywords.some(kw => query.toLowerCase().includes(kw))) {\n    score += 20;\n  }\n\n  // Technical indicators\n  if (/\\d+\\s*[+\\-*/]\\s*\\d+/.test(query)) score += 15; // Math\n  if (/[A-Z]{2,}/.test(query)) score += 10; // Acronyms\n\n  return Math.min(score, 100);\n}\n\n// Router with custom complexity-based routing\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [groq, deepseek, openai, anthropic],\n  strategy: 'custom',\n  customStrategy: (request) => {\n    const query = request.messages[request.messages.length - 1]?.content;\n    const complexity = analyzeComplexity(query.toString());\n\n    if (complexity < 25) return 0; // Groq: Fast & cheap\n    if (complexity < 50) return 1; // DeepSeek: Cost-effective\n    if (complexity < 80) return 2; // OpenAI: Powerful\n    return 3; // Anthropic: Most capable\n  }\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"results",children:"Results"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Automatic provider selection"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Cost optimization while maintaining quality"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 18 diverse test queries validated"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Multiple providers with different capabilities/costs"}),"\n",(0,r.jsx)(n.li,{children:"Query complexity varies significantly"}),"\n",(0,r.jsx)(n.li,{children:"Need to optimize for both cost and quality"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"parallel-provider-aggregation",children:"Parallel Provider Aggregation"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Compare responses from multiple providers side-by-side or ensure redundancy."]}),"\n",(0,r.jsx)(n.h3,{id:"problem-1",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"You want to compare responses from multiple providers simultaneously, or ensure redundancy by calling multiple providers in parallel."}),"\n",(0,r.jsx)(n.h3,{id:"solution-1",children:"Solution"}),"\n",(0,r.jsx)(n.p,{children:"Execute the same request to multiple providers in parallel and aggregate streaming responses in real-time."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Bridge } from 'ai.matey.core';\nimport { EventEmitter } from 'events';\n\nclass ParallelAggregator extends EventEmitter {\n  async executeParallel(request: any, backends: any[]) {\n    const startTime = Date.now();\n\n    const promises = backends.map(async (backend) => {\n      const bridge = new Bridge(\n        new OpenAIFrontendAdapter(),\n        backend\n      );\n\n      try {\n        const response = await bridge.chat(request);\n        const duration = Date.now() - startTime;\n\n        this.emit('response', {\n          provider: backend.name,\n          response,\n          duration,\n          success: true\n        });\n\n        return { provider: backend.name, response, success: true };\n      } catch (error) {\n        this.emit('error', {\n          provider: backend.name,\n          error: error.message\n        });\n\n        return { provider: backend.name, error, success: false };\n      }\n    });\n\n    // Wait for all (graceful failure handling)\n    const results = await Promise.allSettled(promises);\n    return results.map(r => r.status === 'fulfilled' ? r.value : null);\n  }\n}\n\n// Usage\nconst aggregator = new ParallelAggregator();\n\naggregator.on('response', ({ provider, response, duration }) => {\n  console.log(`${provider}: ${response.content} (${duration}ms)`);\n});\n\nconst results = await aggregator.executeParallel(request, backends);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"results-1",children:"Results"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Parallel streaming from 3 providers"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Real-time chunk processing"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Graceful failure handling"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-1",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A/B testing different providers"}),"\n",(0,r.jsx)(n.li,{children:"Ensuring redundancy (if one fails, others succeed)"}),"\n",(0,r.jsx)(n.li,{children:"Comparing response quality"}),"\n",(0,r.jsx)(n.li,{children:"Performance benchmarking"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"automatic-failover",children:"Automatic Failover"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Automatically retry failed requests with fallback providers for high availability."]}),"\n",(0,r.jsx)(n.h3,{id:"problem-2",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"Providers fail due to rate limits, network issues, or service outages. Manual intervention is too slow."}),"\n",(0,r.jsx)(n.h3,{id:"solution-2",children:"Solution"}),"\n",(0,r.jsx)(n.p,{children:"Custom middleware that automatically retries failed requests with the next provider in a fallback chain."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-2",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Router } from 'ai.matey.core';\n\nconst router = new Router(new OpenAIFrontendAdapter(), {\n  backends: [\n    openaiBackend,    // Primary\n    anthropicBackend, // Secondary\n    groqBackend,      // Tertiary\n    deepseekBackend   // Last resort\n  ],\n  strategy: 'priority',\n  fallbackOnError: true,\n  healthCheck: {\n    enabled: true,\n    interval: 60000, // Check every minute\n  },\n});\n\n// Health tracking prevents repeated requests to failing providers\nrouter.on('backend:failed', ({ backend, error }) => {\n  console.log(`${backend} failed: ${error.message}`);\n});\n\nrouter.on('backend:switch', ({ from, to }) => {\n  console.log(`Switched from ${from} to ${to}`);\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"results-2",children:"Results"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Automatic failover between 4 providers"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Health tracking prevents repeated failures"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Comprehensive audit trail"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 10 failure scenarios tested"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-2",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Production systems requiring high availability"}),"\n",(0,r.jsx)(n.li,{children:"When provider reliability varies"}),"\n",(0,r.jsx)(n.li,{children:"Need automatic recovery from failures"}),"\n",(0,r.jsx)(n.li,{children:"Want comprehensive failure logging"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cost-optimized-selection",children:"Cost-Optimized Selection"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Minimize API costs while maintaining quality guarantees."]}),"\n",(0,r.jsx)(n.h3,{id:"problem-3",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"AI API costs can be high. Different providers have vastly different pricing, but you still need quality guarantees."}),"\n",(0,r.jsx)(n.h3,{id:"solution-3",children:"Solution"}),"\n",(0,r.jsx)(n.p,{children:"Estimate request costs across providers, filter by quality tier, and select the cheapest option."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-3",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Provider pricing (per 1K tokens)\nconst PRICING = {\n  deepseek: 0.0002,\n  groq: 0.00027,\n  anthropic: 0.0008,  // Haiku\n  openai: 0.0015      // GPT-3.5\n};\n\n// Quality tiers\nconst QUALITY_TIERS = {\n  low: ['deepseek'],\n  medium: ['deepseek', 'groq'],\n  high: ['groq', 'anthropic', 'openai'],\n  ultra: ['anthropic', 'openai']\n};\n\nfunction selectCheapestProvider(\n  prompt: string,\n  qualityTier: keyof typeof QUALITY_TIERS\n) {\n  const estimatedTokens = Math.ceil((prompt.length + 200) / 4);\n  const eligibleProviders = QUALITY_TIERS[qualityTier];\n\n  let cheapest = eligibleProviders[0];\n  let lowestCost = PRICING[cheapest] * estimatedTokens / 1000;\n\n  for (const provider of eligibleProviders) {\n    const cost = PRICING[provider] * estimatedTokens / 1000;\n    if (cost < lowestCost) {\n      cheapest = provider;\n      lowestCost = cost;\n    }\n  }\n\n  return { provider: cheapest, estimatedCost: lowestCost };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"results-3",children:"Results"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"84% cost savings"})," vs always using OpenAI"]}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Quality tiers ensure acceptable response quality"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Provider distribution: 50% DeepSeek, 30% Groq, 20% Haiku"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-3",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cost optimization is a priority"}),"\n",(0,r.jsx)(n.li,{children:"Flexible quality requirements"}),"\n",(0,r.jsx)(n.li,{children:"Processing high volumes of requests"}),"\n",(0,r.jsx)(n.li,{children:"Providers offer similar capabilities at different prices"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"websocket-real-time-streaming",children:"WebSocket Real-Time Streaming"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Bi-directional real-time communication for chat applications."]}),"\n",(0,r.jsx)(n.h3,{id:"problem-4",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"Need real-time communication for chat applications with streaming AI responses."}),"\n",(0,r.jsx)(n.h3,{id:"solution-4",children:"Solution"}),"\n",(0,r.jsx)(n.p,{children:"WebSocket server with per-client conversation history and real-time streaming delivery."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-4",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import WebSocket from 'ws';\nimport { Bridge } from 'ai.matey.core';\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\n// Per-client state\nconst clients = new Map();\n\nwss.on('connection', (ws) => {\n  const clientId = `client-${Date.now()}`;\n  clients.set(ws, { id: clientId, history: [] });\n\n  ws.on('message', async (data) => {\n    const message = JSON.parse(data.toString());\n    const client = clients.get(ws);\n\n    if (message.type === 'chat') {\n      const bridge = new Bridge(\n        new OpenAIFrontendAdapter(),\n        backend\n      );\n\n      const stream = await bridge.chatStream({\n        messages: [{ role: 'user', content: message.content }],\n        stream: true\n      });\n\n      for await (const chunk of stream) {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify({\n            type: 'chunk',\n            data: chunk\n          }));\n        }\n      }\n\n      ws.send(JSON.stringify({ type: 'done' }));\n    }\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"results-4",children:"Results"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 15/15 tests passing (100%)"}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"101ms latency"})," (ping/pong)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"19 chunks/sec"})," streaming rate"]}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Multi-client concurrent handling"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-4",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Real-time chat applications"}),"\n",(0,r.jsx)(n.li,{children:"Interactive AI assistants"}),"\n",(0,r.jsx)(n.li,{children:"Bi-directional communication requirements"}),"\n",(0,r.jsx)(n.li,{children:"Per-client state management needed"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"batch-processing-with-rate-limiting",children:"Batch Processing with Rate Limiting"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Process many requests quickly without hitting API rate limits."]}),"\n",(0,r.jsx)(n.h3,{id:"problem-5",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"Need to process many requests quickly while respecting provider rate limits."}),"\n",(0,r.jsx)(n.h3,{id:"solution-5",children:"Solution"}),"\n",(0,r.jsx)(n.p,{children:"Queue management with sliding window rate limiting and configurable concurrency."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-5",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class BatchProcessor {\n  private queue: any[] = [];\n  private processing = 0;\n  private requestTimes: number[] = [];\n\n  constructor(\n    private config: {\n      concurrency: number;\n      rateLimit: { maxRequests: number; perMinutes: number };\n    }\n  ) {}\n\n  private canMakeRequest(): boolean {\n    const now = Date.now();\n    const windowStart = now - (this.config.rateLimit.perMinutes * 60 * 1000);\n\n    // Remove old timestamps\n    this.requestTimes = this.requestTimes.filter(t => t > windowStart);\n\n    return this.requestTimes.length < this.config.rateLimit.maxRequests;\n  }\n\n  async add(request: any): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ request, resolve, reject });\n      this.processQueue();\n    });\n  }\n\n  private async processQueue() {\n    while (\n      this.queue.length > 0 &&\n      this.processing < this.config.concurrency &&\n      this.canMakeRequest()\n    ) {\n      const { request, resolve, reject } = this.queue.shift();\n      this.processing++;\n      this.requestTimes.push(Date.now());\n\n      try {\n        const result = await this.execute(request);\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      } finally {\n        this.processing--;\n        this.processQueue();\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"results-5",children:"Results"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"100% success"})," on standard config"]}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Sliding window rate limiting"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Configurable concurrency"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-5",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"High-volume batch processing"}),"\n",(0,r.jsx)(n.li,{children:"Need to respect rate limits"}),"\n",(0,r.jsx)(n.li,{children:"Want configurable concurrency"}),"\n",(0,r.jsx)(n.li,{children:"Processing queued requests"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"advanced-middleware-composition",children:"Advanced Middleware Composition"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Build complex request pipelines with multiple middleware layers."]}),"\n",(0,r.jsx)(n.h3,{id:"implementation-6",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import {\n  createLoggingMiddleware,\n  createRetryMiddleware,\n  createCachingMiddleware,\n  createCostTrackingMiddleware,\n} from 'ai.matey.middleware';\n\nconst bridge = new Bridge(\n  new OpenAIFrontendAdapter(),\n  backend\n);\n\n// Build middleware stack (order matters!)\nbridge.use(createLoggingMiddleware({ level: 'info' }));\nbridge.use(createRetryMiddleware({ maxAttempts: 3 }));\nbridge.use(createCachingMiddleware({ ttl: 3600 }));\nbridge.use(createCostTrackingMiddleware({ budgetLimit: 100 }));\n"})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-6",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Production applications"}),"\n",(0,r.jsx)(n.li,{children:"Need logging, retry, caching, etc."}),"\n",(0,r.jsx)(n.li,{children:"Want separation of concerns"}),"\n",(0,r.jsx)(n.li,{children:"Building reusable pipelines"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"continuous-health-monitoring",children:"Continuous Health Monitoring"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Monitor provider health and performance in real-time."]}),"\n",(0,r.jsx)(n.h3,{id:"implementation-7",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class HealthMonitor {\n  private metrics = new Map();\n\n  trackRequest(provider: string, duration: number, success: boolean) {\n    if (!this.metrics.has(provider)) {\n      this.metrics.set(provider, {\n        requests: 0,\n        failures: 0,\n        totalDuration: 0,\n      });\n    }\n\n    const m = this.metrics.get(provider);\n    m.requests++;\n    if (!success) m.failures++;\n    m.totalDuration += duration;\n  }\n\n  getHealth(provider: string) {\n    const m = this.metrics.get(provider);\n    if (!m) return null;\n\n    return {\n      errorRate: m.failures / m.requests,\n      avgLatency: m.totalDuration / m.requests,\n      healthy: m.failures / m.requests < 0.05, // <5% errors\n    };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-7",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Production monitoring"}),"\n",(0,r.jsx)(n.li,{children:"Need provider health insights"}),"\n",(0,r.jsx)(n.li,{children:"Want to track performance"}),"\n",(0,r.jsx)(n.li,{children:"Building observability"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/examples",children:"Examples"})," - Working code examples"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/packages/middleware",children:"Middleware"})," - Available middleware"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/johnhenry/ai.matey/tree/main/packages/ai.matey.docs/examples/04-routing",children:"Routing Examples"})," - Routing strategies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/johnhenry/ai.matey/tree/main/packages/ai.matey.docs/examples/07-advanced-patterns",children:"Production Patterns"})," - Deployment patterns"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);